A few notes about this program at a high abstraction level.  

  I made a Board class that stores a game state and has data to be a tree node later.  
  I modified AI to add a few functions and to call the new functions and board class as needed.  
  I made a _SuperPiece struct to hold some additional data for pieces (like movements).  
  I do an integrity check on every move I get from the server to ensure the master board in the AI class is never incorrect.  
  In order to count movements, the AI class stores the aforementioned "master" board throughout its life.  


Additional comments for the second assignment
  The TreeSearch class implements the algorithms and has helper functions for doing so; I also moved generate_moves out of AI and into this.  
  AI.cpp currently uses a id dlmm depth limit of 3; 4 will also complete in a reasonable time but won't necessarily get to end-game in all cases; a long game will time out with 4.  
  The heuristic I used is weighted points; (node->informed_points(pid)*0.6)-(node->naive_points(!pid)) is the literal code.  This has the effect of trying to attack the enemy, but not making overly risky sacrifices to do so.  This will very consistently beat the random AI, but obviously I'll work improve it more.  Informed_points at the moment is just naive_points with an addition for when the enemy is in check.  
  Since I cannot look 100 moves ahead, the 100 move stalemate still occasionally happens; it will be detected by the AI, but in some cases insufficient action can be taken to get out of it by the time it's 3 moves away.  

Additional comments for the third assignment
  there is a time_for_this_move function in the TreeSearch class; I also estimated the minimum time it would take to do another iteration within id_minimax and factored that in
  minimax returns early from recursive calls as soon as it runs out of time
  there is a prompt for user-specified algorithm and heuristic use, with a timeout in case the code is run on the arena

Modifications and additions for the fourth assignment (in response to grader feedback)
  I removed the check for opponent in checkmate when opponent isn't at move in the general minimax function, as requested
  I removed the king count from naive_points, and by extension informed_points
  Immediate checkmates are now accounted for, as noted in my previous comments; this prevents trying to go along a path to a further away checkmate when an immediate one exists
    The history table would have largely dimished this effect anyway, but just to be safe

Additional comments for the fourth assignment
  non-quiescent search is done by setting the quiescent depth limit to 0, rather than another boolean argument
  when not using a history table (backwards compatibility) id_minimiax, dl_minimax, and general_min_or_max_pruning will have a "hist" argument value of NULL
    otherwise it will be a pointer to a HistTable object, defined in HistTable.h
  a max-sorting quicksort algorithm is used to order children, it is declared in Board.h and defined in Board.cpp
    it is (indirectly) called at the start of dl_minimax and general_min_or_max_pruning, just after children nodes are generated

